#pragma once
#include <random>
#include "../utility/charlieSort.hpp"
#include "../utility/miniPCG.hpp"
#define RNG MiniPcg32


#ifndef vec 
#define vec std::vector
#endif


template <typename ing>
ing adjustSize(ing N)
{
  ing sqrtN = ing(std::round(std::sqrt(N + 0.0)));
  ing Nnew = sqrtN * sqrtN;
  if (Nnew < N)
  {
    sqrtN += 1;
    N = sqrtN * sqrtN;
  }
  else N = Nnew;
  return N;
}


template <typename ing, typename num>
struct MCgaussianCopula
{
  typedef std::pair<num, num> Bigau;
  // random samples from univariate standard normal distribution.
  // vec<num> gauX, gauY;
  vec<Bigau> gau; // A zero-correlation bivariate Gaussian.
  
  
  void reset(ing N)
  {
    ing Ninitial = N;
    N = adjustSize(N);
    ing sqrtN = std::sqrt(N + 0.5);
    gau.resize(N);
    
    
    num dp = 1.0 / sqrtN;
    RNG rng(1);
    std::uniform_real_distribution<double> U(0, 1);
    for (ing i = 0, k = 0; i < sqrtN; ++i)
    {
      for (ing j = 0; j < sqrtN; ++j, ++k)
      {
        num xp = dp * (i + U(rng));
        num yp = dp * (j + U(rng));
        gau[k].first  = R::qnorm(xp, 0, 1, 1, 0);
        gau[k].second = R::qnorm(yp, 0, 1, 1, 0);
      }
    }
    
    
    std::shuffle(gau.begin(), gau.end(), rng);
    gau.resize(Ninitial);
    N = Ninitial;
    
    
    if (false)
    {
      num cov = 0, firstMean = 0, secondMean = 0;
      for (ing k = 0, kend = gau.size(); k < kend; ++k)
      {
        cov += gau[k].first * gau[k].second;
        firstMean += gau[k].first;
        secondMean += gau[k].second;
      }
      Rcpp::Rcout << "gau cor = " << 
        cov / N - (firstMean / N) * (secondMean / N) << "\n";
    }
    
    
    std::sort(gau.begin(), gau.end(), [](const Bigau &u, const Bigau &v)->bool
      {
          return u.first < v.first;
      });
  }
  
  
  CharlieThreadPool *cp;
  CharlieSort *csort;
  void reset(CharlieThreadPool *cp, CharlieSort *csort)
  {
    this->cp = cp;
    this->csort = csort;
  }
  
  
  MCgaussianCopula(CharlieThreadPool *cp, CharlieSort *csort, ing sampleSize)
  {
    reset(cp, csort);
    reset(sampleSize);
  }
  
  
  vec<num> C;
  
  
  vec<num> Scontainer;
  void operator() (num *X, num *Y, ing size, num *S, num theta, bool decomp, RNG &rng)
  {
    theta = std::max<num> (std::min<num> (theta, 1), 0);
    
    
    if (theta >= 1)
    {
      for (ing i = 0; i < size; ++i) S[i] = X[i] + Y[i];
      return;
    }
    if (theta <= 0) 
    {
      std::shuffle(Y, Y + size, rng);
      for (ing i = 0; i < size; ++i) S[i] = X[i] + Y[i];
      (*csort)(S, S + size, cp);
      return;
    }
    
    
    num *Sreserv = S;
    if ((S >= X and S <= X + size) or (S >= Y and S <= Y + size))
    {
      Scontainer.resize(size);
      S = &Scontainer[0];
    }
    
    
    num *ES, *ES2, *EX, *EX2, *EY, *EY2, *Ecomo, *Ecomo2; 
    if (decomp)
    {
      C.assign(cp->maxCore * 8, 0); 
      ES = &C[0] + 0 * cp->maxCore; ES2 = &C[0] + 1 * cp->maxCore;
      EX = &C[0] + 2 * cp->maxCore; EX2 = &C[0] + 3 * cp->maxCore;
      EY = &C[0] + 4 * cp->maxCore; EY2 = &C[0] + 5 * cp->maxCore;
      Ecomo = &C[0] + 6 * cp->maxCore; Ecomo2 = &C[0] + 7 * cp->maxCore;
    }
    
    
    auto empFun = [](std::size_t)->bool { return false; };  
    cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
    {
      num z = theta * gau[i].first + std::sqrt(1 - theta * theta) * gau[i].second;
      constexpr const num sqrt2inv = 0.7071067811865475244008443621048490392848359376884740365883;
      num zp = (std::erf(z * sqrt2inv) + 1) / 2;
      ing k = std::round(zp * (size - 1));
      if (decomp)
      {
        EX[t] += X[i]; EX2[t] += X[i] * X[i];
        EY[t] += Y[k]; EY2[t] += Y[k] * Y[k];
        num s = X[i] + Y[k];
        ES[t] += s; ES2[t] += s * s;
        s = X[i] + Y[i];
        Ecomo[t] += s; Ecomo2[t] += s * s; 
      }
      else
      {
        S[i] = X[i] + Y[k];  
      }
      return false;
    }, 3000, empFun, empFun);
    
    
    if (decomp)
    {
      num Xmean = std::accumulate(EX,   EX + cp->maxCore, 0.0) / size;
      num Xvar  = std::accumulate(EX2, EX2 + cp->maxCore, 0.0) / size - Xmean * Xmean;
      
      
      num Ymean = std::accumulate(EY,   EY + cp->maxCore, 0.0) / size;
      num Yvar  = std::accumulate(EY2, EY2 + cp->maxCore, 0.0) / size - Ymean * Ymean;
      
      
      num Smean = std::accumulate(ES,   ES + cp->maxCore, 0.0) / size;
      num Svar  = std::accumulate(ES2, ES2 + cp->maxCore, 0.0) / size - Smean * Smean;
      
      
      num ScomoMean = std::accumulate(Ecomo,   Ecomo + cp->maxCore, 0.0) / size;
      num ScomoVar  = std::accumulate(Ecomo2, Ecomo2 + cp->maxCore, 0.0) / size - ScomoMean * ScomoMean;
      
      
      num w = (Svar - (Xvar + Yvar)) / (ScomoVar - (Xvar + Yvar));
      w = std::max<num> (std::min<num> (w, 1.0), 0.0);
      ing n = std::round(w * size);
      
      
      RNG rng2(rng());
      cp->parFor(0, 2, [&](std::size_t i, std::size_t t)->bool
      {
        if (i == 0)
        {
          std::shuffle(X, X + size, rng);
          std::sort(X, X + n);
        }
        else
        {
          std::shuffle(Y, Y + size, rng2);
          std::sort(Y, Y + n);
        }
        return false;
      }, 1, empFun, empFun);
      
      
      cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
      {
        S[i] = X[i] + Y[i];
        return false;
      }, 3000, empFun, empFun);
    }
    
    
    (*csort)(S, S + size, cp);
    
    
    if (S != Sreserv) std::copy(S, S + size, Sreserv);
  }
  
  
};




// Populate a vector of std::pair<num, num> with uncorrelated random uniforms.
template <typename ing, typename num>
void populateUncorrelatedBivarUnif(vec<std::pair<num, num> > &unif, ing N)
{
  ing Ninitial = N;
  N = adjustSize(N);
  ing sqrtN = std::sqrt(N + 0.5);
  unif.resize(N);
  
  
  num dp = 1.0 / sqrtN;
  RNG rng(20);
  // std::uniform_real_distribution<double> U(0, 1);
  for (ing i = 0, k = 0; i < sqrtN; ++i)
  {
    for (ing j = 0; j < sqrtN; ++j, ++k)
    {
      unif[k].first  = dp * (i + 0.5);
      unif[k].second = dp * (j + 0.5);
      // unif[k].first  = dp * (i + 0.5 + (U(rng) - 0.5) * 0.00001 );
      // unif[k].second = dp * (j + 0.5 + (U(rng) - 0.5) * 0.00001 );
    }
  }
  
  
  if (N != Ninitial)
  {
    std::shuffle(unif.begin(), unif.end(), rng);  
  }
  unif.resize(Ninitial);
  N = Ninitial;
  
  
  typedef std::pair<num, num> BiU; 
  std::sort(unif.begin(), unif.end(), [](const BiU &u, const BiU &v)->bool
  {
    return u.first < v.first;
  });
}


template <typename ing, typename num>
struct MCgumbelCopula
{
  typedef std::pair<num, num> BiU;
  vec<BiU> unif; // A zero-correlation bivariate uniform.
  vec<BiU> unifForSamplingFromStableDistr;
  
  
  CharlieThreadPool *cp;
  CharlieSort *csort;
  void reset(CharlieThreadPool *cp, CharlieSort *csort)
  {
    this->cp = cp;
    this->csort = csort;
  }
  
  
  bool useMarshallOlkin;
  MCgumbelCopula(CharlieThreadPool *cp, CharlieSort *csort, ing sampleSize,
                 bool useMarshallOlkin = false)
  {
    reset(cp, csort);
    populateUncorrelatedBivarUnif<ing, num> (unif, sampleSize);
    if (useMarshallOlkin) populateUncorrelatedBivarUnif<ing, num> (
        unifForSamplingFromStableDistr, sampleSize);
    this->useMarshallOlkin = useMarshallOlkin;
  }
  
  
  void solveConditional(num v1, num v2, num &u1, num &u2,
                       num theta, int maxIter = 100, num eps = 1e-6)
  {
    num w = 0.5, a = 1.0 / theta;
    int collision = 0;
    num &v = v2;
    num logw;
    int totalIter = 0;
    int iter = 0;
    for (; iter < maxIter; ++iter)
    {
      logw = std::log(w);
      num oneMinusAlogw = 1 - logw * a;
      num f = w * oneMinusAlogw - v;
      if (std::abs(f) < eps) break;
      num fprime = oneMinusAlogw - a;
      num wnew = w - f / fprime;
      collision += wnew > 1 or wnew < 1e-100;
      if (collision > 3) break;
      w = std::max<num> (1e-100, std::min<num> (1, wnew));
      ++totalIter;
    }
    
    
    if (collision > 3 or iter >= maxIter)
    {
      w = 0.5;
      num wlow = 0, whigh = 1;
      for (int i = 0; i < maxIter; ++i)
      {
        if (wlow >= whigh) break;
        num f = w * (1 - std::log(w) * a) - v;
        if (f > eps) whigh = w;
        else if (f < -eps) wlow = w;
        else break;
        w = (wlow + whigh) / 2;
        ++totalIter;
      }  
    }
    
    
    logw = std::log(w);
    u1 = std::exp(std::pow(v1, a) * logw);
    u2 = std::exp(std::pow(1 - v1, a) * logw);
  }
  
  
  // Sampling from stable distribution as a subroutine for solving Marshall-Olkin.
  // u and v are two independent random numbers.
  num sampleStableDistr(num u, num v, num theta)
  {
    constexpr num thepi = 3.14159265358979323846264338328;
    num W = -std::log(1 - u);
    num U = (v - 0.5) * thepi;
    num alpha = 1 / theta;
    constexpr num beta = 1;
    num c = std::pow(std::cos(thepi / (2 * theta)), theta);
    num mu = theta == 1;
    num zeta = -beta * std::tan(thepi * alpha / 2);
    num X = 0, Y = 0;
    if (alpha == 1)
    {
      constexpr num xi = thepi / 2;
      X = ((thepi / 2 + beta * U) * std::tan(U) - beta * std::log( 
        thepi / 2 * W * std::cos(U) / (thepi / 2 + beta * U) )) / xi;
      Y = c * X + 2 / thepi * beta * c * std::log(c) + mu;
    }
    else
    {
      num xi = std::atan(-zeta) / alpha;
      X = std::pow((1 + zeta * zeta), 1 / (2 * alpha)) * 
        std::sin(alpha * (U + xi)) / std::pow(std::cos(U), 1 / alpha) *
        std::cos(U - alpha * (U + xi)) / W;
      Y = c * X + mu;
    }
    return Y;
  }
  
  
  // Marshall-Olkin
  void solveConditional(num v1, num v2, 
                        num w1, num w2, // These two are for sampling stable distributions.
                        num &u1, num &u2, 
                        num theta)
  {
    num R0 = -std::log(1 - v1), R1 = -std::log(1 - v2);
    num theteInv = 1 / theta;
    num invV = 1 / sampleStableDistr(w1, w2, theta);
    u1 = std::exp(-std::pow(R0 * invV, theteInv));
    u2 = std::exp(-std::pow(R1 * invV, theteInv));
  }
  
  
  vec<num> C;
  
  
  vec<RNG> rngsForMarshallOlkin;
  vec<num> Scontainer;
  void operator() (
      num *X, num *Y, ing size, num *S, num theta, bool decomp, RNG &rng)
  {
    theta = std::max<num> (std::min<num> (theta, 100), 1);
    
    
    if (theta >= 20)
    {
      for (ing i = 0; i < size; ++i) S[i] = X[i] + Y[i];
      return;
    }
    if (theta == 1) 
    {
      std::shuffle(Y, Y + size, rng);
      for (ing i = 0; i < size; ++i) S[i] = X[i] + Y[i];
      (*csort)(S, S + size, cp);
      return;
    }
    
    
    num *Sreserv = S;
    if ((S >= X and S <= X + size) or (S >= Y and S <= Y + size))
    {
      Scontainer.resize(size);
      S = &Scontainer[0];
    }
    
    
    num *ES, *ES2, *EX, *EX2, *EY, *EY2, *Ecomo, *Ecomo2; 
    if (decomp)
    {
      C.assign(cp->maxCore * 8, 0); 
      ES = &C[0] + 0 * cp->maxCore; ES2 = &C[0] + 1 * cp->maxCore;
      EX = &C[0] + 2 * cp->maxCore; EX2 = &C[0] + 3 * cp->maxCore;
      EY = &C[0] + 4 * cp->maxCore; EY2 = &C[0] + 5 * cp->maxCore;
      Ecomo = &C[0] + 6 * cp->maxCore; Ecomo2 = &C[0] + 7 * cp->maxCore;
    }
    
    
    auto empFun = [](std::size_t)->bool { return false; }; 
    
    
    cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
    {
      num u1, u2;
      if (!useMarshallOlkin) solveConditional(
          unif[i].first, unif[i].second, u1, u2, theta, 100, 1e-6);
      else solveConditional(
          unif[i].first, unif[i].second, 
          unifForSamplingFromStableDistr[i].first, 
          unifForSamplingFromStableDistr[i].second, u1, u2, theta);
      
      
      ing j = std::round(u1 * (size - 1));
      ing k = std::round(u2 * (size - 1));
      // Rcpp::Rcout << j << ", " << k << ",  ";
      
      
      if (decomp)
      {
        EX[t] += X[j]; EX2[t] += X[j] * X[j];
        EY[t] += Y[k]; EY2[t] += Y[k] * Y[k];
        num s = X[j] + Y[k];
        ES[t] += s; ES2[t] += s * s;
        s = X[j] + Y[j];
        Ecomo[t] += s; Ecomo2[t] += s * s; 
      }
      else
      {
        S[i] = X[j] + Y[k];  
      }
      return false;
    }, 3000, empFun, empFun);
    
    
    if (decomp)
    {
      num Xmean = std::accumulate(EX,   EX + cp->maxCore, 0.0) / size;
      num Xvar  = std::accumulate(EX2, EX2 + cp->maxCore, 0.0) / size - Xmean * Xmean;
      
      
      num Ymean = std::accumulate(EY,   EY + cp->maxCore, 0.0) / size;
      num Yvar  = std::accumulate(EY2, EY2 + cp->maxCore, 0.0) / size - Ymean * Ymean;
      
      
      num Smean = std::accumulate(ES,   ES + cp->maxCore, 0.0) / size;
      num Svar  = std::accumulate(ES2, ES2 + cp->maxCore, 0.0) / size - Smean * Smean;
      
      
      num ScomoMean = std::accumulate(Ecomo,   Ecomo + cp->maxCore, 0.0) / size;
      num ScomoVar  = std::accumulate(Ecomo2, Ecomo2 + cp->maxCore, 0.0) / size - 
        ScomoMean * ScomoMean;
      
      
      num w = (Svar - (Xvar + Yvar)) / (ScomoVar - (Xvar + Yvar));
      w = std::max<num> (std::min<num> (w, 1.0), 0.0);
      ing n = std::round(w * size);
      
      
      RNG rng2(rng());
      cp->parFor(0, 2, [&](std::size_t i, std::size_t t)->bool
      {
        if (i == 0)
        {
          std::shuffle(X, X + size, rng);
          std::sort(X, X + n);
        }
        else
        {
          std::shuffle(Y, Y + size, rng2);
          std::sort(Y, Y + n);
        }
        return false;
      }, 1, empFun, empFun);
      
      
      cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
      {
        S[i] = X[i] + Y[i];
        return false;
      }, 3000, empFun, empFun);
    }
    
    
    (*csort)(S, S + size, cp);
    
    
    if (S != Sreserv) std::copy(S, S + size, Sreserv);
  }
  
  
};




// https://www.caee.utexas.edu/prof/bhat/ABSTRACTS/Supp_material.pdf
template <typename ing, typename num>
struct MCmorgensternCopula
{
  typedef std::pair<num, num> BiU;
  vec<BiU> unif;
  
  
  // u + theta * (u - 1) * u * (2 v - 1) = w; w, v, theta are given. Solve u. 
  CharlieThreadPool *cp;
  CharlieSort *csort;
  void reset(CharlieThreadPool *cp, CharlieSort *csort)
  {
    this->cp = cp;
    this->csort = csort;
  }
  
  
  MCmorgensternCopula(CharlieThreadPool *cp, CharlieSort *csort, ing sampleSize)
  {
    reset(cp, csort);
    populateUncorrelatedBivarUnif<ing, num> (unif, sampleSize);
  }
  
  
  // u + theta * (u - 1) * u * (2 v - 1) = w
  // w, v, theta are given. Solve u. 
  // w and v are pre-sampled and stored in BiU.
  void solveConditional(num w, num v, num &u1, num &u2,
                        num theta, int maxIter = 100, num eps = 1e-6)
  {
    u1 = v;
    num &u = u2;
    int collision = 0;
    int iter = 0;
    u = 0.5;
    for (; iter < maxIter; ++iter)
    {
      num f = u + theta * (u - 1) * u * (2 * v - 1) - w;
      if (std::abs(f) < eps) break;
      num fprime = theta * (2 * u - 1) * (2 * v - 1) + 1;
      num unew = u - f / fprime;
      collision += unew > 1 or unew < 0;
      if (collision > 3) break;
      u = std::max<num> (0, std::min<num> (1, unew));
    }
    
    
    if (collision > 3 or iter >= maxIter)
    {
      u = 0.5;
      num ulow = 0, uhigh = 1;
      for (int i = 0; i < maxIter; ++i)
      {
        if (ulow >= uhigh) break;
        num f = u + theta * (u - 1) * u * (2 * v - 1) - w;
        if (f > eps) uhigh = u;
        else if (f < -eps) ulow = u;
        else break;
        u = (ulow + uhigh) / 2;
      }  
    }
  }
  
  
  vec<num> C;
  
  
  vec<num> Scontainer;
  void operator() (num *X, num *Y, ing size, num *S,
                num theta, bool decomp, RNG &rng)
  {
    theta = std::max<num> (std::min<num> (theta, 1), 0);
    if (theta <= 0) 
    {
      std::shuffle(Y, Y + size, rng);
      for (ing i = 0; i < size; ++i) S[i] = X[i] + Y[i];
      (*csort)(S, S + size, cp);
      return;
    }
    
    
    num *Sreserv = S;
    if ((S >= X and S <= X + size) or (S >= Y and S <= Y + size))
    {
      Scontainer.resize(size);
      S = &Scontainer[0];
    }
    
    
    num *ES, *ES2, *EX, *EX2, *EY, *EY2, *Ecomo, *Ecomo2; 
    if (decomp)
    {
      C.assign(cp->maxCore * 8, 0); 
      ES =    &C[0] + 0 * cp->maxCore; ES2 =    &C[0] + 1 * cp->maxCore;
      EX =    &C[0] + 2 * cp->maxCore; EX2 =    &C[0] + 3 * cp->maxCore;
      EY =    &C[0] + 4 * cp->maxCore; EY2 =    &C[0] + 5 * cp->maxCore;
      Ecomo = &C[0] + 6 * cp->maxCore; Ecomo2 = &C[0] + 7 * cp->maxCore;
    }
    
    
    cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
    {
      num u1, u2;
      solveConditional(unif[i].first, unif[i].second, u1, u2, theta, 100, 1e-6);
      ing j = std::round(u1 * (size - 1));
      ing k = std::round(u2 * (size - 1));
      
      
      if (decomp)
      {
        EX[t] += X[j]; EX2[t] += X[j] * X[j];
        EY[t] += Y[k]; EY2[t] += Y[k] * Y[k];
        num s = X[j] + Y[k];
        ES[t] += s; ES2[t] += s * s;
        s = X[j] + Y[j];
        Ecomo[t] += s; Ecomo2[t] += s * s; 
      }
      else
      {
        S[i] = X[j] + Y[k];  
      }
      return false;
    }, 3000);
    
    
    if (decomp)
    {
      num Xmean = std::accumulate(EX,   EX + cp->maxCore, 0.0) / size;
      num Xvar  = std::accumulate(EX2, EX2 + cp->maxCore, 0.0) / size - Xmean * Xmean;
      
      
      num Ymean = std::accumulate(EY,   EY + cp->maxCore, 0.0) / size;
      num Yvar  = std::accumulate(EY2, EY2 + cp->maxCore, 0.0) / size - Ymean * Ymean;
      
      
      num Smean = std::accumulate(ES,   ES + cp->maxCore, 0.0) / size;
      num Svar  = std::accumulate(ES2, ES2 + cp->maxCore, 0.0) / size - Smean * Smean;
      
      
      num ScomoMean = std::accumulate(Ecomo,   Ecomo + cp->maxCore, 0.0) / size;
      num ScomoVar  = std::accumulate(Ecomo2, Ecomo2 + cp->maxCore, 0.0) / size - 
        ScomoMean * ScomoMean;
      
      
      num w = (Svar - (Xvar + Yvar)) / (ScomoVar - (Xvar + Yvar));
      w = std::max<num> (std::min<num> (w, 1.0), 0.0);
      ing n = std::round(w * size);
      
      
      RNG rng2(rng());
      cp->parFor(0, 2, [&](std::size_t i, std::size_t t)->bool
      {
        if (i == 0)
        {
          std::shuffle(X, X + size, rng);
          std::sort(X, X + n);
        }
        else
        {
          std::shuffle(Y, Y + size, rng2);
          std::sort(Y, Y + n);
        }
        return false;
      }, 1);
      
      
      cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
      {
        S[i] = X[i] + Y[i];
        return false;
      }, 3000);
    }
    
    
    (*csort)(S, S + size, cp);
    
    
    if (S != Sreserv) std::copy(S, S + size, Sreserv);
  }
  
  
};




template <typename ing, typename num>
struct MCjoeCopula
{
  typedef std::pair<num, num> BiU;
  vec<BiU> unif; // A zero-correlation bivariate uniform.
  // vec<BiU> unifForSamplingFromStableDistr;
  
  
  CharlieThreadPool *cp;
  CharlieSort *csort;
  void reset(CharlieThreadPool *cp, CharlieSort *csort)
  {
    this->cp = cp;
    this->csort = csort;
  }
  
  
  MCjoeCopula(CharlieThreadPool *cp, CharlieSort *csort, ing sampleSize)
  {
    reset(cp, csort);
    populateUncorrelatedBivarUnif<ing, num> (unif, sampleSize);
  }
  
  
  void solveConditional(num v, num f, num &u1, num &u2,
                        num t, int maxIter = 100, num eps = 1e-6) // t is theta.
  {
    
    
    num A = std::pow(1 - v, t - 1);
    num B = A * (1 - v);
    num C = 1 / t - 1;
    num D = (t - 1) * std::log(1 - v) - std::log(f);
    num E = 1 - B;
    num G = E * C;
    
    
    auto objFun = [&B, &C, &E, &G, &D](
      num x, const bool differentiate = true)->std::pair<num, num>
    {
      std::pair<num, num> rst;
      num EXpB = E * x + B;
      rst.first = std::log(1 - x) + C * std::log(EXpB) + D;
      if (differentiate)
        rst.second = 1 / (x - 1) + G / EXpB;
      return rst;
    };
    
    
    int collision = 0, iter = 0;
    num x = 0.5;
    for (; iter < maxIter; ++iter)
    {
      auto ff = objFun(x);
      if (std::abs(ff.first) < eps) break;
      num xnew = x - ff.first / ff.second;
      collision += xnew > 1 or xnew < 0;
      if (collision > 3) break;
      x = std::max<num> (eps, std::min<num> (1 - eps, xnew));
    }
    // Rcpp::Rcout << "\n";
    
    
    if (collision > 3 or iter >= maxIter)
    {
      x = 0.5;
      num xlow = 0 + eps, xhigh = 1 - eps;
      num ylow = objFun(xlow, false).first;
      num yhigh = objFun(xhigh, false).first;
      std::function binf = 
        [&objFun](num x)->num { return objFun(x, false).first; };
      if (ylow > yhigh)
        binf = [&objFun](num x)->num { return -objFun(x, false).first; };
      
      
      for (int i = 0; i < maxIter; ++i)
      {
        if (xhigh - xlow <= eps / 2) break;
        auto ff = binf(x);
        if (ff > eps) xhigh = x;
        else if (ff < -eps) xlow = x;
        else break;
        x = (xlow + xhigh) / 2;
      }
    }
    
    
    u1 = v;
    u2 = 1 - std::pow(x, 1 / t);
    
    
    // Check if the solution is right:
    if (false)
    {
      num u = u2;
      num error = (std::pow(1 - v, t - 1) - std::pow(1 - u, t) * std::pow(1 - v, t - 1)) *
        std::pow( std::pow(1 - u, t) + std::pow(1 - v, t) - 
        std::pow(1 - u, t) * std::pow(1 - v, t) , 1 / t - 1 ) - f;
      Rcpp::Rcout << "error = " << error << "\n";
    }
  }
  
  
  vec<num> C;
  
  
  vec<num> Scontainer;
  void operator() (
      num *X, num *Y, ing size, num *S, num theta, bool decomp, RNG &rng)
  {
    theta = std::max<num> (std::min<num> (theta, 100), 1);
    
    
    if (theta >= 20)
    {
      for (ing i = 0; i < size; ++i) S[i] = X[i] + Y[i];
      return;
    }
    if (theta == 1) 
    {
      std::shuffle(Y, Y + size, rng);
      for (ing i = 0; i < size; ++i) S[i] = X[i] + Y[i];
      (*csort)(S, S + size, cp);
      return;
    }
    
    
    num *Sreserv = S;
    if ((S >= X and S <= X + size) or (S >= Y and S <= Y + size))
    {
      Scontainer.resize(size);
      S = &Scontainer[0];
    }
    
    
    num *ES, *ES2, *EX, *EX2, *EY, *EY2, *Ecomo, *Ecomo2; 
    if (decomp)
    {
      C.assign(cp->maxCore * 8, 0); 
      ES = &C[0] + 0 * cp->maxCore; ES2 = &C[0] + 1 * cp->maxCore;
      EX = &C[0] + 2 * cp->maxCore; EX2 = &C[0] + 3 * cp->maxCore;
      EY = &C[0] + 4 * cp->maxCore; EY2 = &C[0] + 5 * cp->maxCore;
      Ecomo = &C[0] + 6 * cp->maxCore; Ecomo2 = &C[0] + 7 * cp->maxCore;
    }
    
    
    cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
    {
      num u1, u2;
      solveConditional(
        unif[i].first, unif[i].second, u1, u2, theta, 100, 1e-6);
      
      
      ing j = std::round(u1 * (size - 1));
      ing k = std::round(u2 * (size - 1));
      
      
      if (decomp)
      {
        EX[t] += X[j]; EX2[t] += X[j] * X[j];
        EY[t] += Y[k]; EY2[t] += Y[k] * Y[k];
        num s = X[j] + Y[k];
        ES[t] += s; ES2[t] += s * s;
        s = X[j] + Y[j];
        Ecomo[t] += s; Ecomo2[t] += s * s; 
      }
      else
      {
        S[i] = X[j] + Y[k];  
      }
      return false;
    }, 3000);
    
    
    if (decomp)
    {
      num Xmean = std::accumulate(EX,   EX + cp->maxCore, 0.0) / size;
      num Xvar  = std::accumulate(EX2, EX2 + cp->maxCore, 0.0) / size - Xmean * Xmean;
      
      
      num Ymean = std::accumulate(EY,   EY + cp->maxCore, 0.0) / size;
      num Yvar  = std::accumulate(EY2, EY2 + cp->maxCore, 0.0) / size - Ymean * Ymean;
      
      
      num Smean = std::accumulate(ES,   ES + cp->maxCore, 0.0) / size;
      num Svar  = std::accumulate(ES2, ES2 + cp->maxCore, 0.0) / size - Smean * Smean;
      
      
      num ScomoMean = std::accumulate(Ecomo,   Ecomo + cp->maxCore, 0.0) / size;
      num ScomoVar  = std::accumulate(Ecomo2, Ecomo2 + cp->maxCore, 0.0) / size - 
        ScomoMean * ScomoMean;
      
      
      num w = (Svar - (Xvar + Yvar)) / (ScomoVar - (Xvar + Yvar));
      w = std::max<num> (std::min<num> (w, 1.0), 0.0);
      ing n = std::round(w * size);
      
      
      RNG rng2(rng());
      cp->parFor(0, 2, [&](std::size_t i, std::size_t t)->bool
      {
        if (i == 0)
        {
          std::shuffle(X, X + size, rng);
          std::sort(X, X + n);
        }
        else
        {
          std::shuffle(Y, Y + size, rng2);
          std::sort(Y, Y + n);
        }
        return false;
      }, 1);
      
      
      cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
      {
        S[i] = X[i] + Y[i];
        return false;
      }, 3000);
    }
    
    
    (*csort)(S, S + size, cp);
    
    
    if (S != Sreserv) std::copy(S, S + size, Sreserv);
  }
  
  
};




template <typename ing, typename num>
struct MCtCopula
{
  typedef std::pair<float, uint32_t> B;
  vec<B> rt1, rt2;
  
  
  CharlieThreadPool *cp;
  CharlieSort *csort;
  void reset(CharlieThreadPool *cp, CharlieSort *csort)
  {
    this->cp = cp;
    this->csort = csort;
  }
  
  
  std::normal_distribution<float> rnorm;
  MCtCopula(CharlieThreadPool *cp, CharlieSort *csort)
  {
    reset(cp, csort);
  }
  
  
  vec<num> C, Scontainer;
  void operator() (
      num *X, num *Y, ing size, num *S, num theta, int df, bool decomp, RNG &rng)
  {
    theta = std::max<num> (std::min<num> (theta, 1 - 1e-6), -1 + 1e-6);
    rt1.resize(size);
    rt2.resize(size);
    
    
    std::chi_squared_distribution<float> Rchi(df);
    std::normal_distribution<float> Rnorm(0.0, 1.0);
    num sqrtheta = std::sqrt(1 - theta * theta);
    
    
    Rcpp::Rcout << "1.0\n";
    
    
    for (ing i = 0; i < size; ++i)
    {
      uint32_t tmp = rng();
      std::memcpy(&rt1[i].first, &tmp, sizeof(float));
      rt1[i].second = rng();
      rt2[i].second = rng();
    }
    
    
    Rcpp::Rcout << "1.1\n";
    
    
    struct tmpRng
    {
      uint32_t x[3];
      constexpr const static uint32_t min() { return 0ul; }
      constexpr const static uint32_t max() { return 4294967295ul; }
      int counter;
      tmpRng(void *r0, void *r1, void *r2)
      {
        counter = 0;
        std::memcpy(&x[0], r0, sizeof(uint32_t));
        std::memcpy(&x[1], r1, sizeof(uint32_t));
        std::memcpy(&x[2], r2, sizeof(uint32_t));
      }
      uint32_t operator()() { return x[counter]; counter += 1; }
    };
    
    
    cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
    {
      tmpRng trng(&rt1[i].first, &rt1[i].second, &rt2[i].second);
      float a = Rnorm(trng);
      float b = a * theta + Rnorm(trng) * sqrtheta;
      float scalar = std::sqrt(df / Rchi(trng));
      rt1[i].first = scalar * a;
      rt2[i].first = scalar * b;
      return false;
    }, 3000);
    
    
    Rcpp::Rcout << "1.2\n";
    
    
    cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
    {
      rt1[i].second = rt2[i].second = i; return false;
    }, 10000);
    
    
    Rcpp::Rcout << "1.3\n";
    
    
    (*csort) (rt1.begin(), rt1.end(), [](const B &x, const B &y)->bool
    {
      return x.first < y.first;
    });
    (*csort) (rt2.begin(), rt2.end(), [](const B &x, const B &y)->bool
    {
      return x.first < y.first;
    });
    
    
    Rcpp::Rcout << "1.4\n";
    
    
    Scontainer.resize(size);
    cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
    {
      Scontainer[rt1[i].second] = X[i];
      return false;
    }, 10000);
    cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
    {
      Scontainer[rt2[i].second] += Y[i];
      return false;
    }, 10000);
    
    
    Rcpp::Rcout << "1.5\n";
    
    
    num *ES, *ES2, *EX, *EX2, *EY, *EY2;
    C.assign(cp->maxCore * 6, 0); 
    ES = &C[0] + 0 * cp->maxCore; ES2 = &C[0] + 1 * cp->maxCore;
    EX = &C[0] + 2 * cp->maxCore; EX2 = &C[0] + 3 * cp->maxCore;
    EY = &C[0] + 4 * cp->maxCore; EY2 = &C[0] + 5 * cp->maxCore;
    
    
    cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
    {
      ES[t] += Scontainer[i]; ES2[t] += Scontainer[i] * Scontainer[i];
      EX[t] += X[i]; EX2[t] += X[i] * X[i]; 
      EY[t] += Y[i]; EY2[t] += Y[i] * Y[i]; 
      return false;
    }, 3000);
    
    
    Rcpp::Rcout << "1.6\n";
    
    
    ing Ncore = cp->maxCore;
    auto muF = [Ncore, size](num *x)->num { 
      return std::accumulate(x, x + Ncore, 0.0) / size; };
    
    
    Rcpp::Rcout << "1.7\n";
    
    
    num meanS =  muF(ES);
    num meanS2 = muF(ES2);
    num meanX =  muF(EX);
    num meanX2 = muF(EX2);
    num meanY =  muF(EY);
    num meanY2 = muF(EY2);
    
    
    num Xvar = meanX2 - meanX * meanX;
    num Yvar = meanY2 - meanY * meanY;
    num Svar = meanS2 - meanS * meanS;
    num corImposed = (Svar - (Xvar + Yvar)) / (2 * std::sqrt(Xvar * Yvar));
    if (corImposed < 0)
    {
      std::shuffle(Y, Y + size, rng);
      cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
      {
        S[i] = X[i] + Y[i];
        return false;
      }, 10000);
      (*csort)(S, S + size, cp);
      return;
    }
    
    
    if (!decomp) 
    { 
      std::copy(Scontainer.begin(), Scontainer.end(), S); 
      (*csort)(S, S + size, cp);
      return; 
    }
    
    
    num *Ecomo, *Ecomo2; 
    C.assign(cp->maxCore * 2, 0); 
    Ecomo = &C[0] + 0 * cp->maxCore; Ecomo2 = &C[0] + 1 * cp->maxCore;
    cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
    {
      num s = X[i] + Y[i];
      Ecomo[t] += s;
      Ecomo2[t] += s * s;
      return false;
    }, 3000);
    num ScomoMean = muF(Ecomo), ScomoVar = muF(Ecomo2) - ScomoMean * ScomoMean;
    
    
    num w = (Svar - (Xvar + Yvar)) / (ScomoVar - (Xvar + Yvar));
    w = std::max<num> (std::min<num> (w, 1.0), 0.0);
    ing n = std::round(w * size);
    
    
    RNG rng2(rng());
    cp->parFor(0, 2, [&](std::size_t i, std::size_t t)->bool
    {
      if (i == 0)
      {
        std::shuffle(X, X + size, rng);
        std::sort(X, X + n);
      }
      else
      {
        std::shuffle(Y, Y + size, rng2);
        std::sort(Y, Y + n);
      }
      return false;
    }, 1);
    
    
    cp->parFor(0, size, [&](std::size_t i, std::size_t t)->bool
    {
      S[i] = X[i] + Y[i];
      return false;
    }, 10000);
    
    
    (*csort)(S, S + size, cp);
  }
  
  
};


















