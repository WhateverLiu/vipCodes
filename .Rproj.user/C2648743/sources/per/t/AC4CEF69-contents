// ============================================================================
# include <setjmp.h>
jmp_buf env;
// longjmp(env, 1); // This line is the breaking point.
// if(setjmp(env)) return List::create(); // Put this line at the beginning of
// the export function.
// ============================================================================
// [[Rcpp::plugins(cpp11)]]
// [[Rcpp::depends(RcppParallel)]]
// # define ARMA_DONT_PRINT_ERRORS
// [[Rcpp::depends(RcppArmadillo)]]
# include <RcppArmadillo.h>
# include <Rcpp.h>
# include <RcppParallel.h>
# include <chrono>
# include <fstream>
# include <random>
# include "h/dnyTasking.hpp"
# include "pcg/pcg_random.hpp"
# define vec std::vector
# define RNG pcg32
using namespace Rcpp;


// ======================================================================================
// 
// ======================================================================================
// objFun should have member functions:
// 1.  run(): compute the function value.
// 2.  getval(): return the current function value.
// 3.  copy(objFun & x): copy x's content to self.
// 4.  swap(objFun & x): swap contents of x and self.
// 5.  resetRNG(ing seed): reset the random number generator in self.
// 6.  reproduce(objFun & x): given birth into container x: (i) copy() self to x, 
//     add random noises to parameters, execute run().
// ======================================================================================
template<typename ing, typename objFun>
struct cmp
{
  objFun *x;
  cmp() {}
  cmp(objFun *x): x(x) {}
  bool operator() (ing a, ing b) { return x[a].getval() < x[b].getval(); }
};


// for(ing k = survivalSize; k < popuSize; ++k)
// {
//   G[parent[k - survivalSize]].reproduce(G[k]);
// }
template<typename ing, typename num, typename objFun>
struct ParaReproduce
{
  ing survivalSize, *parent;
  objFun *G;
  dynamicTasking *dT;
  void operator() (std::size_t st, std::size_t end)
  {
    for(;;)
    {
      std::size_t objI = 0;
      if(!dT->nextTaskID(objI)) break;
      G[parent[objI]].reproduce(G[objI + survivalSize]);
    }
  }
  ParaReproduce(ing survivalSize, ing *parent, ing parentSize, objFun *G, ing maxCore):
    survivalSize(survivalSize), parent(parent), G(G)
  {
    dynamicTasking dt(maxCore, parentSize); dT = &dt;
    parallelFor(0, maxCore, *this);
  }
};


// Minimization.
template<typename ing, typename num, typename objFun>
void GA(objFun &init, vec<objFun> &result,
        ing popuSize, ing survivalSize,
        ing reproduceSelection, // 0: uniform, 1: linear, 2: inverse kernel.
        ing maxIter, ing randomSeed, ing maxCore)
{
  vec<objFun> G(popuSize);
  for(ing i = 0; i < popuSize; ++i)
  {
    G[i].copy(init);
    G[i].resetRNG(randomSeed + i + 1);
    G[i].run();
  }
  vec<ing> objfodr(popuSize);
  std::iota<ing> (objfodr.begin(), objfodr.end());
  vec<num> pvec(survivalSize, 1.0 / survivalSize);
  if(reproduceSelection == 1)
  {
    for(ing i = 0; i < survivalSize; ++i) 
      pvec[i] = survivalSize - i;
  }
  else if(reproduceSelection == 2)
  {
    for(ing i = 0; i < survivalSize; ++i) 
      pvec[i] = 1.0 / (i + 1);
  }
  std::partial_sum(pvec.begin(), pvec.end(), 0.0);
  for(auto & x: pvec) x /= pvec.back();
  pvec.back() = 1.0;
  
  
  auto U = std::uniform_real_distribution<num> (0, 1);
  RNG rng(randomSeed);
  vec<ing> parent(popuSize - survivalSize);
  for(ing iter = 0; iter < maxIter; ++iter)
  {
    std::partial_sort(objfodr.begin(), objfodr.begin() + survivalSize, 
                      objfodr.end(), cmp<ing, objFun>(&G[0]));
    
    
    for(ing k = survivalSize; k < popuSize; ++k)
    {
      ing u = std::lower_bound(pvec.begin(), pvec.end(), U(rng)) - pvec.begin();
      parent[k - survivalSize] = u;
    }
    
    
    // Parallelize it.
    ParaReproduce(survivalSize, &parent[0], parent.size(), &G[0], maxCore);
    // for(ing k = survivalSize; k < popuSize; ++k)
    // {
    //   G[parent[k - survivalSize]].reproduce(G[k]);
    // }
  }
  std::sort(objfodr.begin(), objfodr.end(), cmp<ing, objFun>(&G[0]));
  result.swap(objfodr);
}


template<typename ing, typename num, typename objFun>
void GA(objFun &init, objFun &result,
        ing popuSize, ing survivalSize,
        ing reproduceSelection, // 0: uniform, 1: linear, 2: inverse kernel.
        ing maxIter, ing randomSeed, ing maxCore)
{
  vec<objFun> rst;
  GA(init, rst, popuSize, survivalSize, reproduceSelection, maxIter, randomSeed, maxCore);
  result.swap(rst[0]);
}















